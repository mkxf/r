paxos算法的目标：
		1. 保证最终只有一个提案被选定
		2. 当提案被选定后，进程最终也能获取到此提案

算法描述：	提案 as TA
	对于一个一致性算法
		需要保证：
			1.在被提出的 TA 中，只有一个被选定
			2.如果没有 TA 被提出，就没有被选定的 TA
			3.当一个 TA 被选定时，进程可以获取到该 TA 的信息
		安全性要求：
			1.只有被提出的 TA 才能被选定
			2.只有一个 TA 被选定
			3.如果该进程认为一个某个 TA 被选定，此 TA 必定是被选定的那个

	--  安全性：是指那些  需要保证永远不会发生的事情
	--    活性：是指那些  最终一定会发生的事情

		参与角色： proposer、acceptor、learner 3个
			   提出者    接受者     学习/旁观？

// 拜占廷将军问题：各军通过 通讯员 共进退，通讯员有叛徒，可能改消息，欺骗将军

// paxos： 议员通过  信使  投票通过法令，
		议员和信使都是兼职，都可能随时离开，
			消息可能会被重复传递 或 丢失
		此情况下，要求法令正确产生 且不冲突

	-- paxos 中不会出现 消息被改的情况，即 拜占廷将军问题

提案的选定：
	proposer 向一个 acceptor集合 发送 TA，
		当此集合中大部分 ->大于1/2 批准这个 TA，认为该 TA 被选定
	另规定 一个 acceptor 只能 批准一个 TA，那么就能保证只有一个 TA 被选定

推导：
	1. 只有一个 TA 被提出，仍可以选出一个 TA 
		->
		P1:  一个 acceptor 必须批准 接受到的第一个 TA
	引出另一个问题：
	2、多个 TA 被不同的 P 提出，可能导致每个 A 都批准接受到的第一个 TA,
			但没有一个 TA 是被多数人批准
			另 5TA  -> 2/3 ，3任意一个 A 出错，都导致无法选定最终 TA。
	SO:
		必须大于 1/2 的 A 批准才行

	P1 + SO -> 暗示一个 A 能够批准不止一个 TA

 D:	 TA -> [编号，value] 表示一个 TA
	1. 一个全局编号（外部生成） 标识每一个被 A 批准的 TA
	2. 一个具有某 value 值的 TA 被半数以上的 A 批准后，认为该 value 被选定，也认为该 TA 被选定。
	-> 该value被选定 ==> 该 TA被选定

		被选定的 TA 都有相同的 value
			-- 也是关于 TA value 的约定 （目的还是最终只选定一个 TA）

	结合编号，此约定可以定义如下： -- 选定就是 1/2 A 批准

	P2：如果【M0，V0】的 TA 被选定，那么所有比编号M0 更高的，且被选定 TA,其value也必须是 V0。
	一个TA被选定，至少被一个 A 批准 =>
		P2a：如果【M0，V0】被选定，那么有比M0更高且被 A 批准的 TA ，value也必须是V0。
	
	通信异步，需要P1保证 TA 会被选定，一个TA可能会在某人A还没收到任何TA时就被选定，所以
		P1+P2a 可以得出：（P1：A批准第一个TA）
		P2b：如果一个【M0，V0】被选定后，之后任何P产生的编号更高的TA，其value都是V0。

	