 
 -----------
I show:
 标准sql规范中，定义4个事务隔离级别(I)，对应事务的处理能力不同

I从低到高

未提交读（未授权读） 允许脏读取   2个事务
   desc: 一个事务正在处理某一数据，并对其进行了更新，但还没提交（未完成事务），
		但允许另一个事务也能够访问该数据
   short: 就是 没提交，能读取

   more  em desc: 事务A操作数据X，原始值为0， 从1加到10，加的过程中，事务B可以读到X的值为1，2,3等
		对这一系列中间值的读取就是未提交读.
  em desc: 事务A  start -----------do .. ----------------- end
		--   读取x的值 ......	再读取x............   再读取x 
		 -- 别的事务在更新X的值，并且没提交，事务A可以读到没提交，但更改后的X的值

已提交读（授权读），不可重复读  3个事务，行级别
	允许获取已提交的数据，但此事务使用的数据

  em desc: 事务A  start -----------do .. ----------------- end
		--   读取x的值 （1） ......	再读取x （2）............   再读取x （3）
		 -- 多个事务（B,C）在更新X的值，B提交，C还在操作，事务A可以读到B提交的值，读不到C操作的值，
			等C提交后，A可以读到C更新后的X的值，
			可能 1 时，读到X是一个值（B没提交）,2读到时是另一个值（B提交，C没提交）,3读到的是C提交后的值
		   A读不到别的事务操作过程中的值，但整个过程中，每次读到X的值，可能都不同，（因为此过程B和C有更新且提交）

可重复读：
	 desc: 在事务处理过程中，多次读取同一个数据，其值都和事务开始时刻是一致的。
		禁用了不可重复读取和脏读取
	
	em desc:   事务A 进行过程中要使用X的值，在此过程中，不管别的事务（不论几个）怎么操作X，每次A读到X的值，都是一样的
		事务A   start -----------do .. ----------------- end
		  读取x的值 ......	再读取x............   再读取x （不变，和start时的一样）
		  此时，尽管有其他事务也在操作 x， 但不影响 事务A 在执行中的读取，3段读取的值都形同
		
串行化 serializable 
	desc: 要求所有事务都被串行执行
		一个接一个执行，不能并行

all desc：
     
		事务A 执行过程中，要读取x，此时x也被事务B和C操作

	事务A start -------------------------------------------> end

	 未提交读		已提交读				|      可重复读           |   串行化
	 (可以读到B的x值的变化，| （只能读到B事务提交后的值	|	（只能读到x=20,   |   不可读
	  即能读到 x=1,2..10 ) |	  即能读到 x=10,x=20，别的读不到 |	即 B 和 C都执行完)|
		|
   
	事务B  【x -> 1,2..10】    -->  事务C【x -> 11,12.. 20】

---------------------------------------  存在 Y	  不可以 N
		 脏读（行级别）|  可重复读（行级别） |  幻读 （表级别）
未提交读			Y		 N			Y

已提交读			N		 N			Y

可重复读			N		 Y			Y

串行化			N		 Y			N

--------------  脏读 只有 未提交读有 ， 可重复读 < 他的 不可以，>= 可以, 幻读，除了 串行化都 会出现

考虑到数据完整性和一致性，以及并发性问题
	一般设置为 已提交读（授权读）
to use: 对于会出现的问题（如：不可重复读、虚读、第二类更新丢失【即事务C更新会丢失，A处理完更新X，会覆盖掉C的更新】）
  how do： 	对于出现这种问题的场合中，由应用程序使用 悲观所 或者 乐观锁 进行事务控制


-------------------------------
 事务4个特征：ACID
	原子性、一致性、隔离性、持久性
 
 原子性（atomicity）： 事务必须是一个原子的操作序列单元，
			各项操作在一个执行过程中，全部成功执行 或者 全部不执行，
			任务一项失败都导致事务失败，已执行的会被撤销并回滚
 一致性（consistency）：事务执行不能破坏数据库数据 的完整性和一致性，
				执行结果必须是使数据库从一个一致性状态 转变到另一个一致性状态
				未完成的事务对数据库修改有一部分已写入到数据库，这时DB处于一种不正确的状态或者不一致的状态
 隔离性（isolation）： 并发执行时，互不干扰，相互隔离 (具体情况见  I show:)
 持久性（durability）：事务提交，对数据库中数据的变更就会永久性保存，
				即使系统崩溃等，只要数据库能重启，就能恢复到事务成功结束的状态

-------------------------

 ---- 幻读

在事务A多次读取构成中，事务B对数据进行了新增操作，导致事务A多次读取的数据不一致。幻读和不可重复读的区别在于，

不可重复是针对记录的update操作，只要在记录上加写锁，就可避免；幻读是对记录的insert操作，

要禁止幻读必须加上全局的写锁(比如在表上加写锁)。 另外说一下两类丢失更新：

------- 第一类丢失更新(回滚丢失，Lost update)。
short: 2个事务，A 中间有B操作，A 回滚覆盖了B

在事务A期间，事务 B对数据进行了更新；在事务A撤销之后，覆盖了事务B已经提交的数据。SQL92没有定义这种现象，标准定义的所有隔离界别都不允许第一类丢失更新发生。

----------第二类丢失更新(覆盖丢失， Second lost update)。
short:2个事务，A 中间有B操作，A 提交覆盖了B

在事务A期间，事务B对数据进行了更新；在事务A提交之后，覆盖了事务B已经提交的数据。第二类丢失更新，实际上和不可重复读是同一种问题。

------------ 脏读(Dirty read)。  
short:2个事务就行

事务A读取了事务B中尚未提交的数据。如果事务B回滚，则A读取使用了错误的数据。

-------- 不可重复度(Unrepeatable read)。
short:需要3个事务 ，见上

在事务A多次的读取过程中，事务 B对数据进行了修改，导致事务A多次读取的数据不一致。
-------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------

三级封锁协议

数据库想要在“合适”的时机阻塞住数据库操作，那么首先要定义好怎么样的时机算是“合适”，因为各个系统支持的业务千差万别，对数据的实时性和有效性的要求也不同。于是数据库理论中就提出了封锁级别的概念，对不同的同步要求采用不同的封锁级别。

三级封锁协议内容如下： 

一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。 二级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。 二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。 三级封锁协议 ：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。