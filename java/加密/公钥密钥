一、加密
公钥加密  1:n  私钥解密
锁        		钥匙

一个私钥 对应 多个公钥

二、认证
 私钥签名，公钥认证
    证明出自谁之手

  发送方： 明文
    MD5或者SHA1 对 明文进行处理 ，得到报文
    			--  做一个杂凑，得到一堆杂凑值我们称它为报文。

     对报文加密 ，得到 摘要 ，即 Digest


  明文 和 摘要  发给 接收方

  接收方：用同样的算法处理明文，得到报文

     用公钥对报文附加的数字签名进行解密，得到摘要

     2个摘要对比，一样

 =====================
 客户端jks文件（带着RootCA）、由RootCA签证的服务端、 CA

 客户端 公钥   认证 RootCA， 即 RootCA 被 客户端信任
 服务端 公钥   认证 RootCA， 即 RootCA 被 服务端信任
 =》 客户端可以信任 服务端

 =======================
     S公钥加密          S密钥解密
客户端 C   ---------->  服务端 S
          <----------
     C密钥解密		  C公钥加密

     ==》
     C 公钥放到 S 的jks 文件
     S 公钥放到 C 的jks 文件
-------------------
使用jks文件来实现Server-Client间的“公钥加密，私钥解密”
上面说了，客户端拥有RootCA的public key，服务端也拥有RootCA的public key，所以客户端与服务端可以彼此间也建立起这条信任链。

但是，信任不代表它们可以实现“公钥加密，私钥解密”。

来看一个例子，这是今天的核心：

需求一、如果我们的客户端对一个web service进行加密，然后传到服务端进行解密。

对于需求一来说：

我们需要在客户端用服务端的公钥加密欲传给服务端的消息，然后在服务端得到客户端传过来的加密消息后我们拿着服务端的私钥进行解密。

需求二、服务端将返回的webservice的内容先用客户端的公钥加密后传给客户端，客户端用自己的私钥进行解密。

对于需求二来说：我们在服务端返回给客户端消息之间先用客户端的公钥对消息进行加密，等消息传到客户端的时候，客户端再拿着客户端自己的私钥进行解密。

是不是就可以满足上述两个需求了？

于是，根据上面的描述我们来做一件事，即：

   把客户端的公钥烧到服务端的jks文件里

   把服务端的公钥烧到客户端的jks文件里

即可达到上面两个需求中的文字描述了

